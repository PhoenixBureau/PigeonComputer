<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="utf-8" />
 <title>Pigeon Computer</title>
 <style>
  @import url(http://fonts.googleapis.com/css?family=Cutive|Oxygen:400,700);
  @import url('static/reset.css');
  @import url('static/grid.css');
  @import url('static/type.css');
 </style>
 <link rel="stylesheet" type="text/css" href="static/toast.css" />
 <!--[if IE]>
  <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
 <![endif]-->
</head>
<body>
 <header role="banner">
 <div class="wrap" id="header-content">
  <h1 class="title">Pigeon Computer</h1>
  <h3 class="tagline">Simple, cheap, ubiquitious, and can fly...</h3>
   <hr>
   <p class="blurb">The Pigeon Computer is a simple, cheap, open, 
    educational system built around the popular <a href="http://www.atmel.com/devices/atmega328p.aspx">ATmega328P</a> micro-chip (used
    in the <a href="http://en.wikipedia.org/wiki/Arduino">Arduino Uno</a>, for example) and
    a <a href="https://github.com/PhoenixBureau/PigeonComputer">set of software tools</a> that make
    programming it straightforward and easy to understand at a very deep
    level.
 </div>
 </header>

<div class="wrap">
 <div class="grids">
  <div id="content" class="grid-two-thirds">

  <h2><a name="huh">What is a Computer Anyway?</a></h2>

  <p>The Pigeon Computer is a simple but sophisticated system for learning
and exploring the fundamentals of computers and programming.

  <p>It is written to support a course or class (as yet pending) to learn
programming from the bit to the compiler.

  <p>There is a <a href="http://phoenixbureau.github.com/PigeonComputer/">DRAFT manual</a> and a Pigeon User Interface that includes:

  <ul>
  <li>An assembler for the ATmega328P micro-controller.
  <li>A polymorphic meta-compiler.
  <li>Forth-like firmware in assembly.
  <li>Simple high-level language for assembly control structures.
  <li>A virtual computer that illustrates Functional Programming.
  </ul>

  <p><a href="https://github.com/PhoenixBureau/PigeonComputer">Source code is released under the GPL (v3) and is hosted on Github</a>

  <p><a href="http://phoenixbureau.github.com/PigeonComputer/">The manual is online in HTML form here</a>

  <p><a href="https://groups.google.com/d/forum/pigeoncomputer">Mailing list</a>

  <p>

  <p>I suspect that most of the trouble teaching
  computers to normal people stems directly from the immense leaps
  of abstraction unwittingly made by teachers already intimately
  familiar with the ground being abridged.

  <p>There are conceptual acres to cross before
  confronting Joe or Jane Normal with something like "a = 23".

  <p>Compound that with the hash of interfaces
  that confront the casual user just to use their computer, let
  alone program it, and you have a sort of perfect storm of
  abstraction-haze to confound and confuse the helpless normal
  despite the inherent simplicity and elegance of the concept(s) of
  the computer.

  <h2><a name="basics">The Basics</a></h2>

  <p>With the above in mind, here's a draft overview
  of a curriculum for teaching anybody programming (and
  thus the deep philosophical and scientific underpinnings
  too.)

  <h3><a name="one-bit">One-bit memory.</a></h3>

  <p>Lesson One: Make a One-bit memory.

  <p>I'm seriously here, your first lesson is
  to make a device, no matter how simple, that stores one bit. It
  can be:

  <ul class="c12" start="1">
    <li>A coin, flip heads for 1, tails for
    0.

    <li>A match, horizontal or vertical, head up
    or head down...

    <li>A short length of string, knotted for 0,
    untied for 1.

    <li>A rubber-band, knotted for 1, unknotted
    for 0.

    <li>A business card, horiz. v. vert., front v.
    back, bent v. straightened.

    <li>Even a light switch from a hardware
    store.
  </ul>

  <p>Literally <span class=
  "c7">any</span><span> binary "storage" scheme could be accepted,
  as long as the student truly</span> <span class=
  "c7">gets</span><span> the arbitrary mapping from a physical
  phenomenon to a binary digit. I am convinced that doing this
  physically, with real world objects, is crucial. Take your time
  here, don't rush.  The binary digit is a deep sucker, it just
  seems so plain on first brush. (Hint: What is the least "stuff"
  you need to make a bit? Sample rate and resolution...  What the
  heck "is" a bit anyway? You can't carry it, but you can transmit
  it, what's up with that? And you can duplicate it? Huh?)</span>

  <h3><a name="mkbyte">Line up eight of them. Make a
  byte.</a></h3>

  <p>Once you've made a bit-store, the next
  lesson involves lining them up and flipping them on and off. 
  Count the states, number them, talk about n-to-the-power-of-two,
  Grey Codes, I Ching, distinguishable states, Boolean logic, all
  the deep meanings already present in more-than-one-bit-ness.
  (Twenty Questions!)

  <p>

  <p>Make concrete the Octet, aka Byte, mention
  ASCII, signed and unsigned "short" ints, Unicode and encodings
  (to bytes) and thence sixteen-bit and larger words.

  <h3>Stack up a bunch of bytes. Make RAM.</h3>

  <p>Take some bytes, at least a dozen, and
  stack them in a column. Count the bytes, introduce the count as
  naming or indexing the bytes, call it RAM. Show how a few
  consecutive bytes of RAM can store a string of ASCII codes. Do a
  couple of math problems using two adjacent bytes as (binary)
  operands and another byte to store the result. Move a couple of
  bytes from one area in the RAM to another.

  <h3>Addresses, numbers, operations, naming. (microcode)</h3>

  <p>Wonder at the beauty and greatness of what
  we've done so far.  We mapped binary digits (bits) to real world
  phenomenon. We used a simple coding system, algebra in base two,
  to encode the integers into bit patterns. We created a "strip" or
  "column" of bits, organized in eight-bit-wide words called bytes
  or octets, and then numbered those, counted them to name them,
  and began to use this abacus-like crude machine of ours to
  perform simple operations like math, logic, and "string"
  manipulation.

  <h4>The Power of Naming</h4>

  <p>Start to make concrete the steps used to
  perform these operations.  Use index cards or something and list
  out the various steps you take in performing a few simple
  math/logic problems and stuff. Do the counting-to-name-things
  trick yet again to enumerate the "microcode" you've developed,
  and lay in a simple program using it.  Act out the Fetch-Execute
  cycle and let people get used to the idea of how simple it is.
  Maybe even assign each instruction of microcode to a different
  person and have the class cooperatively act out the solving of a
  simple math problem or two according to an in-memory machine
  language program. (That will prove viscerally that you don't need
  a brain or mind to "be" a computer. Put another way, some classes
  of mental operation can be <span class=
  "c7">automated</span>, carried out by machine.)

  <p>(You would also introduce the idea that
  RAM can be a lot larger than just a dozen bytes or so, and likely
  mention registers too.)

  <h3>Parsing, Grammar, Compiling.</h3>

  <p>Ahem, some about that.

  <p>The Pigeon User Interface (PUI) is a simple and elegant IDE that
presents the user with a very simple but powerful stack-based virtual
computer that includes commands for assembling object code for the
ATmega328P and compiling high-level languages to assembly.

  <p>To get the students into assembly language the Pigeon Computer system
includes a tiny Forth-like firmware that implements a command
interpreter on the serial port (on-chip USART peripheral) in less than
a kilobyte of object code.

  <p>The firmware is a stub. It is meant to be understood and extended by
the students rather than used as-is.  I have written some commands for
it that give it the ability to use the TWI (I2C) subsystem of the
ATmega328P to communicate with other devices, and used that to talk to
an Inertial Motion Unit and get gyro and accelerometer readings, so
there's that.

  <p>Once students are comfortable with assembly, the PUI includes a tiny,
powerful, and extremely flexible meta-compiler: Val Shorre's Meta-II
(implemented in Python.)  This amazing bit of software is polymorphic
in the sense that you can feed it different compiler descriptions and
it becomes different compilers.

  <p>The underlying Meta-II virtual machine works just like an assembler to
read and "become" a compiler description, then it operates as a
syntax-driven compiler for the language described in the compiler
description.

  <p>It is simple enough to be understood by someone willing to take the
time, yet powerful enough to be used in earnest to develop "little
languages" for use in real projects.  The PUI includes a simple
compiler (a description in Meta-II) that generates control-flow
constructs for the firmware commands, illustrating the path from
hand-coded assembly to high-level languages.

  <p>(Those interested in further information regarding these issues are
urged to examine the work of the Viewpoints Research Institute.)

<hr>

  <p>Last but not least, the virtual computer in the PUI is a stack-based
Forth-like fully Functional Programming not-quite-language.  It mimics
the operation of the firmware but goes far beyond what that code is
capable of as it has the whole of Python and the host machine to work
with.

  <p>When you start the PUI it creates a "roost" directory (I apologize for
the pun) where it writes a Git repository (using a pure-Python Git
implementation called Dulwich) and two files: 'log' and
'system.pickle'.

  <p>Then the GUI starts and the user sees a window with two panes. On the
left is a listbox that shows the contents of the stack and on the
right is a text editor.

  <p>The 'log' file is kept in sync with the contents of the text
(auto-saved two seconds after the last edit) and the 'system.pickle'
file keeps a copy of the serialized state of the PUI and is updated
after every change to the virtual computer's state.  When either of
these files change a commit is made to the git repository.

  <p>This ensures that you never have to save (ever!) and you can never
lose your work (ever!).  When you re-open the PUI it reads the last
state and log from the "roost" directory and loads them, seamlessly
putting you in the exact spot where you left off.

  <p>You can use standard Git tools to examine and check out previous
history.  (Still to do: I want to add means for examining and
replaying histories as well as "cherry picking" objects and data from
previous states into the current one.)

  <p>In addition to the above automatic save mechanism, the text widget
includes undo/redo commands.

  <p>The stack-based virtual computer has a "dictionary" of command words
(like Forth) each of which operates solely on the stack and has no
side effects.  The virtual computer uses only those Python types that
are immutable (string/unicode, numbers, tuples) and this together with
the purely Functional command words means that the entire virtual
machine is pure Functional-Programming-style.

  <p>(One effect of this is that the whole machine state forms one
"persistent" data structure that captures the whole previous history
of every computation the machine performs as the user uses it to e.g.
write code for their chip(s).  This history is kept, serialized in the
'system.pickle' file, and could be made available to the user,
although at the moment it is discarded from the running PUI.  This
whole persistence mechanism is separate and orthogonal to the
git-based history store mentioned above.)


  </div>
  <div class="grid-4">
   <ul class="toc">
    <li><a href="#huh">What is a Computer Anyway?</a>
    <li><a href="#basics">The Basics</a>
       <ul class="toc">
        <li><a href="#one-bit">One-bit memory.</a>
        <li><a href="#mkbyte">Make a byte.</a>
        <li><a href="#mkram">Make RAM.</a>
        <li><a href="#mkram">The Power of Naming.</a>
        <li><a href="#metaii">Parsing, Grammar, Compiling.</a>
       </ul>
    <li><a href="#">The Embellishments</a>
    <li><a href="#">Constructing Programs to Solve Problems</a>
    <li><a href="#">The Assembler</a>
    <li><a href="#">The Meta-Compiler</a>
    <li><a href="#">The Simulator Suite</a>
    <li><a href="#"></a>
   </ul>
  </div>
 </div>
</div>
</body>
</html>
